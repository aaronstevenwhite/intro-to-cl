<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.321">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction to Computational Linguistics - Parsing and Transduction Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../phonological-patterns/phonological-rules-as-fsas/rule-formalism.html" rel="next">
<link href="../../phonological-patterns/phonological-rules-as-fsas/index.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/line-highlight-1.0.0/line-highlight.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../phonological-patterns/index.html">The nature of phonological patterns</a></li><li class="breadcrumb-item"><a href="../../phonological-patterns/phonological-rules-as-fsas/index.html">Phonological rules as FSAs</a></li><li class="breadcrumb-item"><a href="../../phonological-patterns/phonological-rules-as-fsas/parsing-and-transduction.html">Parsing and Transduction Algorithms</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Introduction to Computational Linguistics</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../installation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Installation</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Languages as formal objects</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/sets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sets</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/multisets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Multisets</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/tuples.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tuples</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/cardinality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Cardinality</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/set-relations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Set relations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/power-sets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Power Sets</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/products.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Products</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/relations-and-functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Relations and Functions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/sequences.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sequences</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/strings.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Strings</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-as-formal-objects/languages.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Languages</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Grammars as languages</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/defining-regular-expressions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Defining Regular Expressions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/evaluating-regular-expressions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Evaluating Regular Expressions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/loading-a-lexicon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Loading a Lexicon</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/basic-matching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Basic Matching</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/implementing-the-regular-operations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Implementing the Regular Operations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/wild-cards-and-character-ranges.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Wild cards and character ranges</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/quantifiers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Quantifiers</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../grammars-as-languages/groups-and-greediness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Groups and Greediness</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Uncertainty about Languages</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/what-is-a-probability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">What is a probability?</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/how-we-model-possibilities.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">How we model possibilities</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/what-it-means-to-measure-a-possibility.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">What it means to measure a possibility</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/some-useful-definitions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Some useful definitions</span></a>
  </div>
</li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Random Variables and Probability Distributions</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/random-variables-and-probability-distributions/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Classifying probability spaces</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/random-variables-and-probability-distributions/random-variables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Random variables</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/random-variables-and-probability-distributions/probability-distributions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Probability distributions</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/some-more-useful-definitions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Some useful definitions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../uncertainty-about-languages/statistical-inference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Statistical Inference</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
 <span class="menu-text">Languages in terms of Strings</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-in-terms-of-strings/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-in-terms-of-strings/distance-in-the-abstract.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Distance in the abstract</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../languages-in-terms-of-strings/levenshtein-distance.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Levenshtein distance</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">
 <span class="menu-text">The nature of phonological patterns</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/generation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Generation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/the-generativist-conceit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The Generativist Conceit</span></a>
  </div>
</li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="false">
 <span class="menu-text">Formal definition</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/formal-definition/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/formal-definition/two-equivalent-definitions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Two equivalent definitions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/formal-definition/the-regular-operations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The regular operations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/formal-definition/translating-between-formalisms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Translating Regular Expressions to NFAs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/formal-definition/beyond-the-regular-operations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The intersection operation via complement</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false">
 <span class="menu-text">Recognition and parsing</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/recognition-and-parsing/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/recognition-and-parsing/recognition.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Recognition</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/recognition-and-parsing/parsing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Parsing</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true">
 <span class="menu-text">Phonological rules as FSAs</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/phonological-rules-as-fsas/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/phonological-rules-as-fsas/parsing-and-transduction.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Parsing and Transduction Algorithms</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/phonological-rules-as-fsas/rule-formalism.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Phonological Rule Formalism</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" aria-expanded="false">
 <span class="menu-text">Generative capacity</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/generative-capacity/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../phonological-patterns/generative-capacity/pumping-lemma.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The Pumping Lemma for Regular Languages</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" aria-expanded="true">
 <span class="menu-text">The nature of morphological patterns</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-11" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../syntactic-patterns/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" aria-expanded="true">
 <span class="menu-text">Analysis as deduction</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-12" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../analysis-as-deduction/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" aria-expanded="true">
 <span class="menu-text">The nature of syntactic patterns</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-13" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../syntactic-patterns/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-14" aria-expanded="true">
 <span class="menu-text">Assignments</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-14" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-14" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../assignments/assignments-1-and-2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Assignments 1 and 2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../assignments/assignments-3-and-4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Assignments 3 and 4</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#parsing-and-transduction-with-finite-state-transducers" id="toc-parsing-and-transduction-with-finite-state-transducers" class="nav-link active" data-scroll-target="#parsing-and-transduction-with-finite-state-transducers">Parsing and Transduction with Finite State Transducers</a></li>
  <li><a href="#the-transduction-problem" id="toc-the-transduction-problem" class="nav-link" data-scroll-target="#the-transduction-problem">The Transduction Problem</a></li>
  <li><a href="#parsing-with-fsts" id="toc-parsing-with-fsts" class="nav-link" data-scroll-target="#parsing-with-fsts">Parsing with FSTs</a></li>
  <li><a href="#transduction-algorithm" id="toc-transduction-algorithm" class="nav-link" data-scroll-target="#transduction-algorithm">Transduction Algorithm</a></li>
  <li><a href="#ambiguity-in-transduction" id="toc-ambiguity-in-transduction" class="nav-link" data-scroll-target="#ambiguity-in-transduction">Ambiguity in Transduction</a></li>
  <li><a href="#weighted-transduction" id="toc-weighted-transduction" class="nav-link" data-scroll-target="#weighted-transduction">Weighted Transduction</a></li>
  <li><a href="#applications-in-phonology" id="toc-applications-in-phonology" class="nav-link" data-scroll-target="#applications-in-phonology">Applications in Phonology</a>
  <ul class="collapse">
  <li><a href="#phonological-rule-application" id="toc-phonological-rule-application" class="nav-link" data-scroll-target="#phonological-rule-application">1. Phonological Rule Application</a></li>
  <li><a href="#morphophonological-analysis" id="toc-morphophonological-analysis" class="nav-link" data-scroll-target="#morphophonological-analysis">2. Morphophonological Analysis</a></li>
  <li><a href="#bidirectional-analysis" id="toc-bidirectional-analysis" class="nav-link" data-scroll-target="#bidirectional-analysis">3. Bidirectional Analysis</a></li>
  <li><a href="#optimality-theory-implementation" id="toc-optimality-theory-implementation" class="nav-link" data-scroll-target="#optimality-theory-implementation">4. Optimality Theory Implementation</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Parsing and Transduction Algorithms</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="parsing-and-transduction-with-finite-state-transducers" class="level2">
<h2 class="anchored" data-anchor-id="parsing-and-transduction-with-finite-state-transducers">Parsing and Transduction with Finite State Transducers</h2>
<p>While the rule formalism provides a way to express phonological rules, we need algorithms to apply these rules to linguistic data. This section formalizes the parsing and transduction algorithms for Finite State Transducers (FSTs).</p>
</section>
<section id="the-transduction-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-transduction-problem">The Transduction Problem</h2>
<p>The <em>transduction problem</em> for FSTs can be defined as:</p>
<ul>
<li><strong>Input</strong>: A finite state transducer <span class="math inline">\(T = \langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle\)</span> and a string <span class="math inline">\(\boldsymbol\sigma \in \Sigma^*\)</span></li>
<li><strong>Output</strong>: The set of all strings <span class="math inline">\(\boldsymbol\gamma \in \Gamma^*\)</span> such that <span class="math inline">\((\boldsymbol\sigma, \boldsymbol\gamma) \in \mathbb{R}(T)\)</span>, where <span class="math inline">\(\mathbb{R}(T)\)</span> is the relation defined by <span class="math inline">\(T\)</span></li>
</ul>
<p>In phonological terms, given an underlying representation (input string), we want to find all possible surface representations (output strings) that can be produced by applying the phonological rules encoded in the transducer.</p>
</section>
<section id="parsing-with-fsts" class="level2">
<h2 class="anchored" data-anchor-id="parsing-with-fsts">Parsing with FSTs</h2>
<p>Similar to parsing with FSAs, parsing with FSTs involves finding all possible paths through the transducer that accept the input string. However, for FSTs, we also need to keep track of the output symbols produced along each path.</p>
<p>Let’s define a path through an FST as a sequence of transition tuples, where each tuple represents a transition in the transducer. Formally, a path is represented as:</p>
<p><span class="math display">\[\langle (\sigma_1, \gamma_1, q_1), (\sigma_2, \gamma_2, q_2), \ldots, (\sigma_n, \gamma_n, q_n) \rangle\]</span></p>
<p>where <span class="math inline">\(q_i \in Q\)</span>, <span class="math inline">\(\sigma_i \in \Sigma \cup \{\epsilon\}\)</span>, <span class="math inline">\(\gamma_i \in \Gamma \cup \{\epsilon\}\)</span>, and <span class="math inline">\((q_i, \gamma_i) \in \delta(q_{i-1}, \sigma_i)\)</span> for all <span class="math inline">\(1 \leq i \leq n\)</span>, with <span class="math inline">\(q_0\)</span> being the initial state.</p>
<p>Each tuple <span class="math inline">\((\sigma_i, \gamma_i, q_i)\)</span> indicates that the input symbol <span class="math inline">\(\sigma_i\)</span> was read, the output symbol <span class="math inline">\(\gamma_i\)</span> was produced, and the transducer moved to state <span class="math inline">\(q_i\)</span>.</p>
</section>
<section id="transduction-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="transduction-algorithm">Transduction Algorithm</h2>
<p>To perform transduction, we need to extend our parsing algorithm to collect the output symbols along each path. We’ll define a function <span class="math inline">\(\text{transduce}(T, \boldsymbol\sigma)\)</span> that returns the set of all possible output strings if <span class="math inline">\(\boldsymbol\sigma\)</span> can be transduced by <span class="math inline">\(T\)</span>, and the empty set otherwise.</p>
<p>First, we need a helper function to handle epsilon transitions. Let’s define <span class="math inline">\(\text{epsilon-paths}(q)\)</span> as the set of all paths from state <span class="math inline">\(q\)</span> to any other state using only epsilon input transitions:</p>
<p><span class="math display">\[\text{epsilon-paths}(q) = \{\langle (\epsilon, \gamma_1, q_1), (\epsilon, \gamma_2, q_2), \ldots, (\epsilon, \gamma_n, q_n) \rangle \mid q_1, \ldots, q_n \in Q \text{ and there is a path from } q \text{ to } q_n \text{ using only } \epsilon \text{ input transitions}\}\]</span></p>
<p>We’ll define a transduction function <span class="math inline">\(\text{transduce-from}(T, \boldsymbol\sigma, P)\)</span> where <span class="math inline">\(P\)</span> is a set of partial paths:</p>
<p><span class="math display">\[\text{transduce-from}(T, \boldsymbol\sigma, P) = \begin{cases}
\text{collect-outputs}(\text{find-accepting-paths}(P)) &amp; \text{if } \boldsymbol\sigma = \epsilon \\
\text{transduce-from}(T, \sigma_2\ldots\sigma_n, P') &amp; \text{if } \boldsymbol\sigma = \sigma_1\sigma_2\ldots\sigma_n \\
\emptyset &amp; \text{otherwise}
\end{cases}\]</span></p>
<p>where: - <span class="math inline">\(\text{find-accepting-paths}(P)\)</span> returns the set of paths from <span class="math inline">\(P\)</span> that end in an accepting state, or <span class="math inline">\(\emptyset\)</span> if no such paths exist - <span class="math inline">\(\text{collect-outputs}(P)\)</span> extracts the output strings from a set of paths - <span class="math inline">\(P' = \{p \circ \langle (\sigma_1, \gamma, q') \rangle \circ \epsilon\text{-path} \mid p \in P, \text{last-state}(p) = q, (q', \gamma) \in \delta(q, \sigma_1), \epsilon\text{-path} \in \text{epsilon-paths}(q')\}\)</span></p>
<p>The function <span class="math inline">\(\text{last-state}(p)\)</span> returns the state at the end of path <span class="math inline">\(p\)</span>.</p>
<p>To initialize the transduction, we need to consider all possible paths from the initial state via epsilon transitions:</p>
<p><span class="math display">\[\text{transduce}(T, \boldsymbol\sigma) = \text{transduce-from}(T, \boldsymbol\sigma, \{\langle \rangle \circ \epsilon\text{-path} \mid \epsilon\text{-path} \in \text{epsilon-paths}(q_0)\})\]</span></p>
<p>After reading the entire input string, we must also consider any epsilon transitions that can be taken from the final states:</p>
<p><span class="math display">\[\text{find-accepting-paths}(P) = \{p \circ \epsilon\text{-path} \mid p \in P, \epsilon\text{-path} \in \text{epsilon-paths}(\text{last-state}(p)), \text{last-state}(\epsilon\text{-path}) \in F\}\]</span></p>
<p>Finally, to extract the output strings from a set of paths, we concatenate the output symbols along each path:</p>
<p><span class="math display">\[\text{collect-outputs}(P) = \{\gamma_1\gamma_2\ldots\gamma_n \mid \langle (\sigma_1, \gamma_1, q_1), (\sigma_2, \gamma_2, q_2), \ldots, (\sigma_n, \gamma_n, q_n) \rangle \in P\}\]</span></p>
</section>
<section id="ambiguity-in-transduction" class="level2">
<h2 class="anchored" data-anchor-id="ambiguity-in-transduction">Ambiguity in Transduction</h2>
<p>Just as with FSA parsing, ambiguity is an important consideration in FST transduction. A single input string may be transduced to multiple output strings if the transducer is nondeterministic. In such cases, the transduction algorithm returns the set of all valid output strings.</p>
<p>For example, consider an FST that implements optional vowel harmony. The input string “ev+DE” might be transduced to both “evde” (with harmony) and “evda” (without harmony) if the transducer allows both possibilities.</p>
<p>Handling ambiguity is particularly important in phonological analysis, where different transductions may correspond to different phonological processes or dialectal variations.</p>
</section>
<section id="weighted-transduction" class="level2">
<h2 class="anchored" data-anchor-id="weighted-transduction">Weighted Transduction</h2>
<p>In many phonological applications, we want to find not just any valid transduction, but the most likely or optimal one according to some criterion. This can be achieved using weighted FSTs, where each transition is associated with a weight (e.g., a probability or a cost).</p>
<p>For weighted FSTs, the transduction algorithm needs to be modified to keep track of the weights along each path and to return the output string(s) with the optimal weight.</p>
<p>Let’s define a weighted path as:</p>
<p><span class="math display">\[\langle (\sigma_1, \gamma_1, q_1, w_1), (\sigma_2, \gamma_2, q_2, w_2), \ldots, (\sigma_n, \gamma_n, q_n, w_n) \rangle\]</span></p>
<p>where <span class="math inline">\(w_i\)</span> is the weight associated with the transition from <span class="math inline">\(q_{i-1}\)</span> to <span class="math inline">\(q_i\)</span> on input <span class="math inline">\(\sigma_i\)</span> and output <span class="math inline">\(\gamma_i\)</span>.</p>
<p>The weight of a path is computed by combining the weights of its transitions using an appropriate operation (e.g., multiplication for probabilities, addition for costs):</p>
<p><span class="math display">\[\text{weight}(p) = w_1 \otimes w_2 \otimes \ldots \otimes w_n\]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> is the weight combination operation.</p>
<p>The weighted transduction algorithm returns the output string(s) with the optimal weight:</p>
<p><span class="math display">\[\text{best-transduce}(T, \boldsymbol\sigma) = \{\gamma \mid \gamma \in \text{transduce}(T, \boldsymbol\sigma) \text{ and } \text{weight}(\gamma) \text{ is optimal}\}\]</span></p>
<p>In practice, efficient algorithms like the Viterbi algorithm can be used to find the best transduction without explicitly enumerating all possible paths.</p>
</section>
<section id="applications-in-phonology" class="level2">
<h2 class="anchored" data-anchor-id="applications-in-phonology">Applications in Phonology</h2>
<p>The parsing and transduction algorithms for FSTs have several important applications in phonology:</p>
<section id="phonological-rule-application" class="level3">
<h3 class="anchored" data-anchor-id="phonological-rule-application">1. Phonological Rule Application</h3>
<p>Transduction can model how phonological rules transform underlying representations into surface forms.</p>
<p>For example, transducing the underlying form /kæt+z/ through an FST implementing English plural formation rules would produce the surface form [kæts], showing how the plural morpheme /-z/ undergoes devoicing after the voiceless consonant /t/.</p>
</section>
<section id="morphophonological-analysis" class="level3">
<h3 class="anchored" data-anchor-id="morphophonological-analysis">2. Morphophonological Analysis</h3>
<p>Parsing with FSTs can reveal the morphophonological structure of words by identifying the specific path through the transducer that accepts the input.</p>
<p>For instance, parsing the Turkish word “evde” through a vowel harmony FST would show that the locative suffix “-de” has the front vowel “e” because it follows the front vowel “e” in the stem “ev”.</p>
</section>
<section id="bidirectional-analysis" class="level3">
<h3 class="anchored" data-anchor-id="bidirectional-analysis">3. Bidirectional Analysis</h3>
<p>FSTs can be used for both generation (UR → SR) and analysis (SR → UR), making them powerful tools for bidirectional phonological modeling.</p>
<p>For example, the same FST that transduces /kæt+z/ to [kæts] can be inverted to analyze [kæts] as /kæt+z/, revealing the underlying morphological structure.</p>
</section>
<section id="optimality-theory-implementation" class="level3">
<h3 class="anchored" data-anchor-id="optimality-theory-implementation">4. Optimality Theory Implementation</h3>
<p>While FSTs are traditionally associated with rule-based phonology, they can also be used to implement constraint-based approaches like Optimality Theory (OT) <span class="citation" data-cites="Prince1993">(<a href="#ref-Prince1993" role="doc-biblioref"><strong>Prince1993?</strong></a>)</span>. This is typically done by:</p>
<ol type="1">
<li>Using a weighted FST to generate all possible candidates</li>
<li>Using weighted constraints to assign violation marks to candidates</li>
<li>Finding the optimal candidate(s) using the weighted transduction algorithm</li>
</ol>
<p>This approach has been successfully used to implement OT analyses of various phonological phenomena <span class="citation" data-cites="Karttunen1998">(<a href="#ref-Karttunen1998" role="doc-biblioref"><strong>Karttunen1998?</strong></a>)</span>.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The parsing and transduction algorithms for FSTs provide a formal and computational foundation for applying phonological rules to linguistic data. By formalizing these algorithms, we can:</p>
<ol type="1">
<li>Ensure that rule application is consistent and well-defined</li>
<li>Handle complex cases like ambiguity and optionality</li>
<li>Implement efficient computational tools for phonological analysis</li>
</ol>
<p>These algorithms bridge the gap between formal rule notation and practical application, allowing phonologists to test their analyses on real data and to develop computational models of phonological processes.</p>
<p>In combination with the rule formalism discussed in the previous section, these algorithms provide a complete framework for expressing and applying phonological rules using finite state methods.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="aaronstevenwhite/intro-to-cl" data-repo-id="R_kgDOLDRKkw" data-category="General" data-category-id="DIC_kwDOLDRKk84CcfKw" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../phonological-patterns/phonological-rules-as-fsas/index.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Overview</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../phonological-patterns/phonological-rules-as-fsas/rule-formalism.html" class="pagination-link">
        <span class="nav-page-text">Phonological Rule Formalism</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb1" data-shortcodes="false" data-code-line-numbers=""><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Parsing and Transduction Algorithms</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> ../../references.bib</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">## Parsing and Transduction with Finite State Transducers</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>While the rule formalism provides a way to express phonological rules, we need algorithms to apply these rules to linguistic data. This section formalizes the parsing and transduction algorithms for Finite State Transducers (FSTs).</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Transduction Problem</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>The *transduction problem* for FSTs can be defined as:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Input**: A finite state transducer $T = \langle Q, \Sigma, \Gamma, \delta, q_0, F \rangle$ and a string $\boldsymbol\sigma \in \Sigma^*$</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Output**: The set of all strings $\boldsymbol\gamma \in \Gamma^*$ such that $(\boldsymbol\sigma, \boldsymbol\gamma) \in \mathbb{R}(T)$, where $\mathbb{R}(T)$ is the relation defined by $T$</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>In phonological terms, given an underlying representation (input string), we want to find all possible surface representations (output strings) that can be produced by applying the phonological rules encoded in the transducer.</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="fu">## Parsing with FSTs</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>Similar to parsing with FSAs, parsing with FSTs involves finding all possible paths through the transducer that accept the input string. However, for FSTs, we also need to keep track of the output symbols produced along each path.</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>Let's define a path through an FST as a sequence of transition tuples, where each tuple represents a transition in the transducer. Formally, a path is represented as:</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>$$\langle (\sigma_1, \gamma_1, q_1), (\sigma_2, \gamma_2, q_2), \ldots, (\sigma_n, \gamma_n, q_n) \rangle$$</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>where $q_i \in Q$, $\sigma_i \in \Sigma \cup <span class="sc">\{</span>\epsilon<span class="sc">\}</span>$, $\gamma_i \in \Gamma \cup <span class="sc">\{</span>\epsilon<span class="sc">\}</span>$, and $(q_i, \gamma_i) \in \delta(q_{i-1}, \sigma_i)$ for all $1 \leq i \leq n$, with $q_0$ being the initial state.</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>Each tuple $(\sigma_i, \gamma_i, q_i)$ indicates that the input symbol $\sigma_i$ was read, the output symbol $\gamma_i$ was produced, and the transducer moved to state $q_i$.</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="fu">## Transduction Algorithm</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>To perform transduction, we need to extend our parsing algorithm to collect the output symbols along each path. We'll define a function $\text{transduce}(T, \boldsymbol\sigma)$ that returns the set of all possible output strings if $\boldsymbol\sigma$ can be transduced by $T$, and the empty set otherwise.</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>First, we need a helper function to handle epsilon transitions. Let's define $\text{epsilon-paths}(q)$ as the set of all paths from state $q$ to any other state using only epsilon input transitions:</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>$$\text{epsilon-paths}(q) = <span class="sc">\{</span>\langle (\epsilon, \gamma_1, q_1), (\epsilon, \gamma_2, q_2), \ldots, (\epsilon, \gamma_n, q_n) \rangle \mid q_1, \ldots, q_n \in Q \text{ and there is a path from } q \text{ to } q_n \text{ using only } \epsilon \text{ input transitions}<span class="sc">\}</span>$$</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>We'll define a transduction function $\text{transduce-from}(T, \boldsymbol\sigma, P)$ where $P$ is a set of partial paths:</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>$$\text{transduce-from}(T, \boldsymbol\sigma, P) = \begin{cases}</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>\text{collect-outputs}(\text{find-accepting-paths}(P)) &amp; \text{if } \boldsymbol\sigma = \epsilon <span class="sc">\\</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>\text{transduce-from}(T, \sigma_2\ldots\sigma_n, P') &amp; \text{if } \boldsymbol\sigma = \sigma_1\sigma_2\ldots\sigma_n <span class="sc">\\</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>\emptyset &amp; \text{otherwise}</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>\end{cases}$$</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>where:</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\text{find-accepting-paths}(P)$ returns the set of paths from $P$ that end in an accepting state, or $\emptyset$ if no such paths exist</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\text{collect-outputs}(P)$ extracts the output strings from a set of paths</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$P' = <span class="sc">\{</span>p \circ \langle (\sigma_1, \gamma, q') \rangle \circ \epsilon\text{-path} \mid p \in P, \text{last-state}(p) = q, (q', \gamma) \in \delta(q, \sigma_1), \epsilon\text{-path} \in \text{epsilon-paths}(q')<span class="sc">\}</span>$</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>The function $\text{last-state}(p)$ returns the state at the end of path $p$.</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>To initialize the transduction, we need to consider all possible paths from the initial state via epsilon transitions:</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>$$\text{transduce}(T, \boldsymbol\sigma) = \text{transduce-from}(T, \boldsymbol\sigma, <span class="sc">\{</span>\langle \rangle \circ \epsilon\text{-path} \mid \epsilon\text{-path} \in \text{epsilon-paths}(q_0)<span class="sc">\}</span>)$$</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>After reading the entire input string, we must also consider any epsilon transitions that can be taken from the final states:</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>$$\text{find-accepting-paths}(P) = <span class="sc">\{</span>p \circ \epsilon\text{-path} \mid p \in P, \epsilon\text{-path} \in \text{epsilon-paths}(\text{last-state}(p)), \text{last-state}(\epsilon\text{-path}) \in F<span class="sc">\}</span>$$</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>Finally, to extract the output strings from a set of paths, we concatenate the output symbols along each path:</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>$$\text{collect-outputs}(P) = <span class="sc">\{</span>\gamma_1\gamma_2\ldots\gamma_n \mid \langle (\sigma_1, \gamma_1, q_1), (\sigma_2, \gamma_2, q_2), \ldots, (\sigma_n, \gamma_n, q_n) \rangle \in P<span class="sc">\}</span>$$</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="fu">## Ambiguity in Transduction</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>Just as with FSA parsing, ambiguity is an important consideration in FST transduction. A single input string may be transduced to multiple output strings if the transducer is nondeterministic. In such cases, the transduction algorithm returns the set of all valid output strings.</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>For example, consider an FST that implements optional vowel harmony. The input string "ev+DE" might be transduced to both "evde" (with harmony) and "evda" (without harmony) if the transducer allows both possibilities.</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>Handling ambiguity is particularly important in phonological analysis, where different transductions may correspond to different phonological processes or dialectal variations.</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a><span class="fu">## Weighted Transduction</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>In many phonological applications, we want to find not just any valid transduction, but the most likely or optimal one according to some criterion. This can be achieved using weighted FSTs, where each transition is associated with a weight (e.g., a probability or a cost).</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>For weighted FSTs, the transduction algorithm needs to be modified to keep track of the weights along each path and to return the output string(s) with the optimal weight.</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>Let's define a weighted path as:</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>$$\langle (\sigma_1, \gamma_1, q_1, w_1), (\sigma_2, \gamma_2, q_2, w_2), \ldots, (\sigma_n, \gamma_n, q_n, w_n) \rangle$$</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>where $w_i$ is the weight associated with the transition from $q_{i-1}$ to $q_i$ on input $\sigma_i$ and output $\gamma_i$.</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>The weight of a path is computed by combining the weights of its transitions using an appropriate operation (e.g., multiplication for probabilities, addition for costs):</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>$$\text{weight}(p) = w_1 \otimes w_2 \otimes \ldots \otimes w_n$$</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>where $\otimes$ is the weight combination operation.</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>The weighted transduction algorithm returns the output string(s) with the optimal weight:</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>$$\text{best-transduce}(T, \boldsymbol\sigma) = <span class="sc">\{</span>\gamma \mid \gamma \in \text{transduce}(T, \boldsymbol\sigma) \text{ and } \text{weight}(\gamma) \text{ is optimal}<span class="sc">\}</span>$$</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>In practice, efficient algorithms like the Viterbi algorithm can be used to find the best transduction without explicitly enumerating all possible paths.</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a><span class="fu">## Applications in Phonology</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>The parsing and transduction algorithms for FSTs have several important applications in phonology:</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a><span class="fu">### 1. Phonological Rule Application</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>Transduction can model how phonological rules transform underlying representations into surface forms.</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>For example, transducing the underlying form /kæt+z/ through an FST implementing English plural formation rules would produce the surface form <span class="co">[</span><span class="ot">kæts</span><span class="co">]</span>, showing how the plural morpheme /-z/ undergoes devoicing after the voiceless consonant /t/.</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a><span class="fu">### 2. Morphophonological Analysis</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>Parsing with FSTs can reveal the morphophonological structure of words by identifying the specific path through the transducer that accepts the input.</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>For instance, parsing the Turkish word "evde" through a vowel harmony FST would show that the locative suffix "-de" has the front vowel "e" because it follows the front vowel "e" in the stem "ev".</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a><span class="fu">### 3. Bidirectional Analysis</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>FSTs can be used for both generation (UR → SR) and analysis (SR → UR), making them powerful tools for bidirectional phonological modeling.</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>For example, the same FST that transduces /kæt+z/ to <span class="co">[</span><span class="ot">kæts</span><span class="co">]</span> can be inverted to analyze <span class="co">[</span><span class="ot">kæts</span><span class="co">]</span> as /kæt+z/, revealing the underlying morphological structure.</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="fu">### 4. Optimality Theory Implementation</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>While FSTs are traditionally associated with rule-based phonology, they can also be used to implement constraint-based approaches like Optimality Theory (OT) <span class="co">[</span><span class="ot">@Prince1993</span><span class="co">]</span>. This is typically done by:</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Using a weighted FST to generate all possible candidates</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Using weighted constraints to assign violation marks to candidates</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Finding the optimal candidate(s) using the weighted transduction algorithm</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>This approach has been successfully used to implement OT analyses of various phonological phenomena <span class="co">[</span><span class="ot">@Karttunen1998</span><span class="co">]</span>.</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>The parsing and transduction algorithms for FSTs provide a formal and computational foundation for applying phonological rules to linguistic data. By formalizing these algorithms, we can:</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Ensure that rule application is consistent and well-defined</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Handle complex cases like ambiguity and optionality</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Implement efficient computational tools for phonological analysis</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>These algorithms bridge the gap between formal rule notation and practical application, allowing phonologists to test their analyses on real data and to develop computational models of phonological processes.</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>In combination with the rule formalism discussed in the previous section, these algorithms provide a complete framework for expressing and applying phonological rules using finite state methods. </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



<script src="../../site_libs/quarto-contrib/line-highlight-1.0.0/line-highlight.js" defer="true"></script>
</body></html>