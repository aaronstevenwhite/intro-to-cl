---
title: Phonological Rule Formalism
bibliography: ../../references.bib
---

## The SPE Rule Formalism

The standard formalism for phonological rules comes from Chomsky and Halle's "The Sound Pattern of English" (SPE) [@Chomsky1968]. In this formalism, rules have the general form:

$$A \rightarrow B / C\_D$$

Where:
- $A$ is the target (what changes)
- $B$ is the structural change (what $A$ changes to)
- $C$ is the left context
- $D$ is the right context

This can be read as "$A$ becomes $B$ when it occurs between $C$ and $D$."

The rule applies whenever the sequence $CAD$ is found in the input string, transforming it to $CBD$ in the output.

## Features and Natural Classes

In phonology, segments are often represented as bundles of features rather than atomic symbols. For example, the segment [p] might be represented as:

$$\begin{bmatrix} +\text{consonantal} \\ -\text{sonorant} \\ -\text{continuant} \\ -\text{voice} \\ \text{labial} \end{bmatrix}$$

This allows rules to target natural classes of sounds that share certain features. For example, the rule for German final devoicing can be written as:

$$\begin{bmatrix} +\text{obstruent} \\ +\text{voice} \end{bmatrix} \rightarrow \begin{bmatrix} -\text{voice} \end{bmatrix} / \_ \#$$

This rule applies to all voiced obstruents (b, d, g, v, z, etc.) rather than having to list each one separately.

## Types of Phonological Rules

Phonological rules can be categorized into several types:

1. **Assimilation**: A segment becomes more similar to a neighboring segment
   - Example: Turkish vowel harmony, where suffix vowels match the backness of stem vowels

2. **Dissimilation**: A segment becomes less similar to a neighboring segment
   - Example: Latin liquid dissimilation, where /l-l/ sequences become /r-l/

3. **Insertion (Epenthesis)**: A segment is added
   - Example: English schwa insertion in plurals like "bushes" /bʊʃəz/

4. **Deletion (Elision)**: A segment is removed
   - Example: French liaison, where final consonants are deleted except before vowel-initial words

5. **Metathesis**: Segments change order
   - Example: Old English "hros" becoming Modern English "horse"

6. **Fortition**: A segment becomes stronger
   - Example: Spanish /b/ becoming [b] after nasals

7. **Lenition**: A segment becomes weaker
   - Example: Spanish /b/ becoming [β] between vowels

## Converting Rules to FSTs

To convert a phonological rule $A \rightarrow B / C\_D$ into an FST, we need to:

1. Create an FST that recognizes the pattern $CAD$ in the input
2. Ensure that when this pattern is recognized, $A$ is replaced by $B$ in the output
3. Ensure that all other segments are copied unchanged from input to output

The algorithm developed by @Kaplan1994 and refined by @Mohri1997 provides a systematic way to do this.

### The Replace Operator

The core of the Kaplan and Kay algorithm is the "replace" operator, which can be defined as:

$$\text{replace}(A, B, C, D) = \{(x, y) \mid y \text{ is the result of replacing all instances of } A \text{ with } B \text{ in } x \text{ when } A \text{ occurs between } C \text{ and } D\}$$

This operator defines a regular relation that can be implemented as an FST.

### Context-Dependent Rewrite (CDRewrite)

The replace operator is often implemented as a function called "context-dependent rewrite" (CDRewrite), which takes four arguments:

$$\text{CDRewrite}(\Phi, \Lambda, \rho, \Sigma^*)$$

Where:
- $\Phi$ is the replacement mapping ($A \rightarrow B$)
- $\Lambda$ is the left context ($C$)
- $\rho$ is the right context ($D$)
- $\Sigma^*$ is the universe of strings over which the rule applies

### Example: German Final Devoicing

For German final devoicing, we can express the rule as:

$$\text{CDRewrite}(\{b \rightarrow p, d \rightarrow t, g \rightarrow k, v \rightarrow f, z \rightarrow s, \text{ʒ} \rightarrow \text{ʃ}\}, \epsilon, \#, \Sigma^*)$$

This creates an FST that implements the rule:

$$[+\text{obstruent}, +\text{voice}] \rightarrow [-\text{voice}] / \_ \#$$

### Example: Turkish Vowel Harmony

For Turkish vowel harmony, we need to track the backness of the last vowel in the stem:

$$\text{CDRewrite}(E \rightarrow e, \{e, i, ö, ü\}C^*, \epsilon, \Sigma^*) \cup \text{CDRewrite}(E \rightarrow a, \{a, ı, o, u\}C^*, \epsilon, \Sigma^*)$$

This creates an FST that implements the rule:

$$E \rightarrow [αback] / [αback]C^*\_$$

Where $E$ is an abstract vowel that takes on the backness of the preceding vowel.

## The Formal Algorithm

The formal algorithm for converting a rule $A \rightarrow B / C\_D$ into an FST involves several steps:

1. Create FSTs for $A$, $B$, $C$, and $D$
2. Create an FST that recognizes the pattern $CAD$
3. Create an FST that replaces $A$ with $B$ when it occurs in the context $C\_D$
4. Create an FST that copies all other symbols unchanged

The key insight of @Kaplan1994 was that this can be done using regular operations on FSTs, specifically composition and projection.

@Mohri1997 improved the algorithm by introducing the concept of "factoring" the replace operation, which makes it more efficient and handles certain edge cases correctly.

## Composition of Rules

One of the powerful aspects of the FST approach is that multiple rules can be composed into a single FST. If we have two rules represented as FSTs $T_1$ and $T_2$, we can create a new FST $T = T_1 \circ T_2$ that applies both rules in sequence.

For example, if we have a rule for German final devoicing and another rule for German schwa epenthesis, we can compose them to create a single FST that applies both rules:

$$T = T_{\text{final-devoicing}} \circ T_{\text{schwa-epenthesis}}$$

This is particularly useful for modeling rule ordering in phonology, where the order in which rules apply can affect the final output.

## Conclusion

The SPE rule formalism provides a powerful way to describe phonological processes, and the work of @Kaplan1994 and @Mohri1997 showed how these rules can be systematically converted to FSTs. This connection between phonological theory and computational models has been extremely fruitful, leading to advances in both theoretical understanding and practical applications.

In the next section, we'll explore how to handle more complex phonological phenomena using FSTs, including opacity, long-distance dependencies, and exceptions. 